   1               		.file	"Descriptors.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.CALLBACK_USB_GetDescriptor,"ax",@progbits
  11               	.global	CALLBACK_USB_GetDescriptor
  13               	CALLBACK_USB_GetDescriptor:
  14               	.LFB94:
  15               		.file 1 "Descriptors.c"
   1:Descriptors.c **** /*
   2:Descriptors.c ****              LUFA Library
   3:Descriptors.c ****      Copyright (C) Dean Camera, 2011.
   4:Descriptors.c **** 
   5:Descriptors.c ****   dean [at] fourwalledcubicle [dot] com
   6:Descriptors.c ****            www.lufa-lib.org
   7:Descriptors.c **** */
   8:Descriptors.c **** 
   9:Descriptors.c **** /*
  10:Descriptors.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Descriptors.c **** 
  12:Descriptors.c ****   Permission to use, copy, modify, distribute, and sell this
  13:Descriptors.c ****   software and its documentation for any purpose is hereby granted
  14:Descriptors.c ****   without fee, provided that the above copyright notice appear in
  15:Descriptors.c ****   all copies and that both that the copyright notice and this
  16:Descriptors.c ****   permission notice and warranty disclaimer appear in supporting
  17:Descriptors.c ****   documentation, and that the name of the author not be used in
  18:Descriptors.c ****   advertising or publicity pertaining to distribution of the
  19:Descriptors.c ****   software without specific, written prior permission.
  20:Descriptors.c **** 
  21:Descriptors.c ****   The author disclaim all warranties with regard to this
  22:Descriptors.c ****   software, including all implied warranties of merchantability
  23:Descriptors.c ****   and fitness.  In no event shall the author be liable for any
  24:Descriptors.c ****   special, indirect or consequential damages or any damages
  25:Descriptors.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Descriptors.c ****   in an action of contract, negligence or other tortious action,
  27:Descriptors.c ****   arising out of or in connection with the use or performance of
  28:Descriptors.c ****   this software.
  29:Descriptors.c **** */
  30:Descriptors.c **** 
  31:Descriptors.c **** /** \file
  32:Descriptors.c ****  *
  33:Descriptors.c ****  *  USB Device Descriptors, for library use when in USB device mode. Descriptors are special
  34:Descriptors.c ****  *  computer-readable structures which the host requests upon device enumeration, to determine
  35:Descriptors.c ****  *  the device's capabilities and functions.
  36:Descriptors.c ****  */
  37:Descriptors.c **** 
  38:Descriptors.c **** #include "Descriptors.h"
  39:Descriptors.c **** 
  40:Descriptors.c **** /** Device descriptor structure. This descriptor, located in SRAM memory, describes the overall
  41:Descriptors.c ****  *  device characteristics, including the supported USB version, control endpoint size and the
  42:Descriptors.c ****  *  number of device configurations. The descriptor is read out by the USB host when the enumeratio
  43:Descriptors.c ****  *  process begins.
  44:Descriptors.c ****  */
  45:Descriptors.c **** const USB_Descriptor_Device_t DeviceDescriptor =
  46:Descriptors.c **** {
  47:Descriptors.c **** 	.Header                 = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
  48:Descriptors.c **** 
  49:Descriptors.c **** 	.USBSpecification       = VERSION_BCD(01.10),
  50:Descriptors.c **** 	.Class                  = CDC_CSCP_CDCClass,
  51:Descriptors.c **** 	.SubClass               = CDC_CSCP_NoSpecificSubclass,
  52:Descriptors.c **** 	.Protocol               = CDC_CSCP_NoSpecificProtocol,
  53:Descriptors.c **** 
  54:Descriptors.c **** 	.Endpoint0Size          = FIXED_CONTROL_ENDPOINT_SIZE,
  55:Descriptors.c **** 
  56:Descriptors.c **** 	.VendorID               = DEVICE_VID,
  57:Descriptors.c **** 	.ProductID              = DEVICE_PID,
  58:Descriptors.c **** 	.ReleaseNumber          = VERSION_BCD(00.01),
  59:Descriptors.c **** 
  60:Descriptors.c **** 	.ManufacturerStrIndex   = 0x02,
  61:Descriptors.c **** 	.ProductStrIndex        = 0x01,
  62:Descriptors.c **** 	.SerialNumStrIndex      = NO_DESCRIPTOR,
  63:Descriptors.c **** 
  64:Descriptors.c **** 	.NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS
  65:Descriptors.c **** };
  66:Descriptors.c **** 
  67:Descriptors.c **** /** Configuration descriptor structure. This descriptor, located in SRAM memory, describes the usag
  68:Descriptors.c ****  *  of the device in one of its supported configurations, including information about any device in
  69:Descriptors.c ****  *  and endpoints. The descriptor is read out by the USB host during the enumeration process when s
  70:Descriptors.c ****  *  a configuration so that the host may correctly communicate with the USB device.
  71:Descriptors.c ****  */
  72:Descriptors.c **** const USB_Descriptor_Configuration_t ConfigurationDescriptor =
  73:Descriptors.c **** {
  74:Descriptors.c **** 	.Config =
  75:Descriptors.c **** 		{
  76:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Configuration_Header_t), .Type = DTYPE_
  77:Descriptors.c **** 
  78:Descriptors.c **** 			.TotalConfigurationSize = sizeof(USB_Descriptor_Configuration_t),
  79:Descriptors.c **** 			.TotalInterfaces        = 2,
  80:Descriptors.c **** 
  81:Descriptors.c **** 			.ConfigurationNumber    = 1,
  82:Descriptors.c **** 			.ConfigurationStrIndex  = NO_DESCRIPTOR,
  83:Descriptors.c **** 
  84:Descriptors.c **** 			.ConfigAttributes       = USB_CONFIG_ATTR_BUSPOWERED,
  85:Descriptors.c **** 
  86:Descriptors.c **** 			.MaxPowerConsumption    = USB_CONFIG_POWER_MA(100)
  87:Descriptors.c **** 		},
  88:Descriptors.c **** 
  89:Descriptors.c **** 	.CDC_CCI_Interface =
  90:Descriptors.c **** 		{
  91:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
  92:Descriptors.c **** 
  93:Descriptors.c **** 			.InterfaceNumber        = 0,
  94:Descriptors.c **** 			.AlternateSetting       = 0,
  95:Descriptors.c **** 
  96:Descriptors.c **** 			.TotalEndpoints         = 1,
  97:Descriptors.c **** 
  98:Descriptors.c **** 			.Class                  = CDC_CSCP_CDCClass,
  99:Descriptors.c **** 			.SubClass               = CDC_CSCP_ACMSubclass,
 100:Descriptors.c **** 			.Protocol               = CDC_CSCP_ATCommandProtocol,
 101:Descriptors.c **** 
 102:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 103:Descriptors.c **** 		},
 104:Descriptors.c **** 
 105:Descriptors.c **** 	.CDC_Functional_Header =
 106:Descriptors.c **** 		{
 107:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalHeader_t), .Type = DTYPE_
 108:Descriptors.c **** 			.Subtype                = 0x00,
 109:Descriptors.c **** 
 110:Descriptors.c **** 			.CDCSpecification       = VERSION_BCD(01.10),
 111:Descriptors.c **** 		},
 112:Descriptors.c **** 
 113:Descriptors.c **** 	.CDC_Functional_ACM =
 114:Descriptors.c **** 		{
 115:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalACM_t), .Type = DTYPE_CSI
 116:Descriptors.c **** 			.Subtype                = 0x02,
 117:Descriptors.c **** 
 118:Descriptors.c **** 			.Capabilities           = 0x04,
 119:Descriptors.c **** 		},
 120:Descriptors.c **** 
 121:Descriptors.c **** 	.CDC_Functional_Union =
 122:Descriptors.c **** 		{
 123:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalUnion_t), .Type = DTYPE_C
 124:Descriptors.c **** 			.Subtype                = 0x06,
 125:Descriptors.c **** 
 126:Descriptors.c **** 			.MasterInterfaceNumber  = 0,
 127:Descriptors.c **** 			.SlaveInterfaceNumber   = 1,
 128:Descriptors.c **** 		},
 129:Descriptors.c **** 
 130:Descriptors.c **** 	.CDC_NotificationEndpoint =
 131:Descriptors.c **** 		{
 132:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 133:Descriptors.c **** 
 134:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM),
 135:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 136:Descriptors.c **** 			.EndpointSize           = CDC_NOTIFICATION_EPSIZE,
 137:Descriptors.c **** 			.PollingIntervalMS      = 0xFF
 138:Descriptors.c **** 		},
 139:Descriptors.c **** 
 140:Descriptors.c **** 	.CDC_DCI_Interface =
 141:Descriptors.c **** 		{
 142:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 143:Descriptors.c **** 
 144:Descriptors.c **** 			.InterfaceNumber        = 1,
 145:Descriptors.c **** 			.AlternateSetting       = 0,
 146:Descriptors.c **** 
 147:Descriptors.c **** 			.TotalEndpoints         = 2,
 148:Descriptors.c **** 
 149:Descriptors.c **** 			.Class                  = CDC_CSCP_CDCDataClass,
 150:Descriptors.c **** 			.SubClass               = CDC_CSCP_NoDataSubclass,
 151:Descriptors.c **** 			.Protocol               = CDC_CSCP_NoDataProtocol,
 152:Descriptors.c **** 
 153:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 154:Descriptors.c **** 		},
 155:Descriptors.c **** 
 156:Descriptors.c **** 	.CDC_DataOutEndpoint =
 157:Descriptors.c **** 		{
 158:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 159:Descriptors.c **** 
 160:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_OUT | CDC_RX_EPNUM),
 161:Descriptors.c **** 			.Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 162:Descriptors.c **** 			.EndpointSize           = CDC_TXRX_EPSIZE,
 163:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 164:Descriptors.c **** 		},
 165:Descriptors.c **** 
 166:Descriptors.c **** 	.CDC_DataInEndpoint =
 167:Descriptors.c **** 		{
 168:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 169:Descriptors.c **** 
 170:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | CDC_TX_EPNUM),
 171:Descriptors.c **** 			.Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 172:Descriptors.c **** 			.EndpointSize           = CDC_TXRX_EPSIZE,
 173:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 174:Descriptors.c **** 		}
 175:Descriptors.c **** };
 176:Descriptors.c **** 
 177:Descriptors.c **** /** Language descriptor structure. This descriptor, located in SRAM memory, is returned when the ho
 178:Descriptors.c ****  *  the string descriptor with index 0 (the first index). It is actually an array of 16-bit integer
 179:Descriptors.c ****  *  via the language ID table available at USB.org what languages the device supports for its strin
 180:Descriptors.c ****  */
 181:Descriptors.c **** const USB_Descriptor_String_t LanguageString =
 182:Descriptors.c **** {
 183:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(1), .Type = DTYPE_String},
 184:Descriptors.c **** 
 185:Descriptors.c **** 	.UnicodeString          = {LANGUAGE_ID_ENG}
 186:Descriptors.c **** };
 187:Descriptors.c **** 
 188:Descriptors.c **** /** Product descriptor string. This is a Unicode string containing the product's details in human r
 189:Descriptors.c ****  *  and is read out upon request by the host when the appropriate string ID is requested, listed in
 190:Descriptors.c ****  *  Descriptor.
 191:Descriptors.c ****  */
 192:Descriptors.c **** const USB_Descriptor_String_t ProductString =
 193:Descriptors.c **** {
 194:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(12), .Type = DTYPE_String},
 195:Descriptors.c **** 
 196:Descriptors.c **** 	#if DEVICE_PID == 0x00FA
 197:Descriptors.c **** 	.UnicodeString			= L"Clyde       "
 198:Descriptors.c **** 	#else
 199:Descriptors.c **** 	.UnicodeString			= L"USB IO board"
 200:Descriptors.c **** 	#endif
 201:Descriptors.c **** };
 202:Descriptors.c **** 
 203:Descriptors.c **** const USB_Descriptor_String_t ManufNameString = 
 204:Descriptors.c **** {
 205:Descriptors.c **** 	.Header					= {.Size = USB_STRING_LEN(7), .Type = DTYPE_String},
 206:Descriptors.c **** 	
 207:Descriptors.c **** 	#if DEVICE_VID == 0x3228
 208:Descriptors.c **** 	.UnicodeString			= L"Fabule "
 209:Descriptors.c **** 	#else
 210:Descriptors.c **** 	.UnicodeString			= L"Unknown"
 211:Descriptors.c **** 	#endif
 212:Descriptors.c **** };
 213:Descriptors.c **** 
 214:Descriptors.c **** /** This function is called by the library when in device mode, and must be overridden (see LUFA li
 215:Descriptors.c ****  *  documentation) by the application code so that the address and size of a requested descriptor c
 216:Descriptors.c ****  *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, 
 217:Descriptors.c ****  *  is called so that the descriptor details can be passed back and the appropriate descriptor sent
 218:Descriptors.c ****  *  USB host.
 219:Descriptors.c ****  */
 220:Descriptors.c **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 221:Descriptors.c ****                                     const uint8_t wIndex,
 222:Descriptors.c ****                                     const void** const DescriptorAddress)
 223:Descriptors.c **** {
  16               		.loc 1 223 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
 224:Descriptors.c **** 	const uint8_t  DescriptorType   = (wValue >> 8);
  23               		.loc 1 224 0
  24 0000 292F      		mov r18,r25
  25 0002 30E0      		ldi r19,0
 225:Descriptors.c **** 	const uint8_t  DescriptorNumber = (wValue & 0xFF);
 226:Descriptors.c **** 
 227:Descriptors.c **** 	const void* Address = NULL;
 228:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 229:Descriptors.c **** 
 230:Descriptors.c **** 	switch (DescriptorType)
 231:Descriptors.c **** 	{
 232:Descriptors.c **** 		case DTYPE_Device:
 233:Descriptors.c **** 			Address = &DeviceDescriptor;
 234:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
 235:Descriptors.c **** 			break;
 236:Descriptors.c **** 		case DTYPE_Configuration:
 237:Descriptors.c **** 			Address = &ConfigurationDescriptor;
 238:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
 239:Descriptors.c **** 			break;
 240:Descriptors.c **** 		case DTYPE_String:
 241:Descriptors.c **** 			if (!(DescriptorNumber))
 242:Descriptors.c **** 			{
 243:Descriptors.c **** 				Address = &LanguageString;
 244:Descriptors.c **** 				Size    = LanguageString.Header.Size;
 245:Descriptors.c **** 			}
 246:Descriptors.c **** 			else if (DescriptorNumber == DeviceDescriptor.ProductStrIndex) 
 247:Descriptors.c **** 			{
 248:Descriptors.c **** 				Address = &ProductString;
 249:Descriptors.c **** 				Size    = ProductString.Header.Size;
 250:Descriptors.c **** 			} else if (DescriptorNumber == DeviceDescriptor.ManufacturerStrIndex)
 251:Descriptors.c **** 			{
 252:Descriptors.c **** 				Address = &ManufNameString;
 253:Descriptors.c **** 				Size	= ManufNameString.Header.Size;
 254:Descriptors.c **** 			}
 255:Descriptors.c **** 
 256:Descriptors.c **** 			break;
 257:Descriptors.c **** 	}
 258:Descriptors.c **** 
 259:Descriptors.c **** 	*DescriptorAddress = Address;
 260:Descriptors.c **** 	return Size;
 261:Descriptors.c **** }
  26               		.loc 1 261 0
  27 0004 3327      		clr r19
 230:Descriptors.c **** 	switch (DescriptorType)
  28               		.loc 1 230 0
  29 0006 2230      		cpi r18,2
  30 0008 3105      		cpc r19,__zero_reg__
  31 000a 01F0      		breq .L4
  32 000c 2330      		cpi r18,3
  33 000e 3105      		cpc r19,__zero_reg__
  34 0010 01F0      		breq .L5
  35 0012 2130      		cpi r18,1
  36 0014 3105      		cpc r19,__zero_reg__
  37 0016 01F0      		breq .L6
  38 0018 00C0      		rjmp .L10
  39               	.L4:
  40               	.LVL1:
 238:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  41               		.loc 1 238 0
  42 001a 2EE3      		ldi r18,lo8(62)
  43 001c 30E0      		ldi r19,0
 237:Descriptors.c **** 			Address = &ConfigurationDescriptor;
  44               		.loc 1 237 0
  45 001e 80E0      		ldi r24,lo8(ConfigurationDescriptor)
  46 0020 90E0      		ldi r25,hi8(ConfigurationDescriptor)
  47               	.LVL2:
 239:Descriptors.c **** 			break;
  48               		.loc 1 239 0
  49 0022 00C0      		rjmp .L3
  50               	.LVL3:
  51               	.L5:
 241:Descriptors.c **** 			if (!(DescriptorNumber))
  52               		.loc 1 241 0
  53 0024 8823      		tst r24
  54 0026 01F0      		breq .L7
 246:Descriptors.c **** 			else if (DescriptorNumber == DeviceDescriptor.ProductStrIndex) 
  55               		.loc 1 246 0
  56 0028 8130      		cpi r24,lo8(1)
  57 002a 01F0      		breq .L8
 250:Descriptors.c **** 			} else if (DescriptorNumber == DeviceDescriptor.ManufacturerStrIndex)
  58               		.loc 1 250 0
  59 002c 8230      		cpi r24,lo8(2)
  60 002e 01F0      		breq .L9
  61               	.L10:
 228:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
  62               		.loc 1 228 0
  63 0030 20E0      		ldi r18,0
  64 0032 30E0      		ldi r19,0
 227:Descriptors.c **** 	const void* Address = NULL;
  65               		.loc 1 227 0
  66 0034 80E0      		ldi r24,0
  67 0036 90E0      		ldi r25,0
  68               	.LVL4:
  69 0038 00C0      		rjmp .L3
  70               	.LVL5:
  71               	.L6:
 234:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  72               		.loc 1 234 0
  73 003a 22E1      		ldi r18,lo8(18)
  74 003c 30E0      		ldi r19,0
 233:Descriptors.c **** 			Address = &DeviceDescriptor;
  75               		.loc 1 233 0
  76 003e 80E0      		ldi r24,lo8(DeviceDescriptor)
  77 0040 90E0      		ldi r25,hi8(DeviceDescriptor)
  78               	.LVL6:
  79 0042 00C0      		rjmp .L3
  80               	.LVL7:
  81               	.L7:
 244:Descriptors.c **** 				Size    = LanguageString.Header.Size;
  82               		.loc 1 244 0
  83 0044 24E0      		ldi r18,lo8(4)
  84 0046 30E0      		ldi r19,0
 243:Descriptors.c **** 				Address = &LanguageString;
  85               		.loc 1 243 0
  86 0048 80E0      		ldi r24,lo8(LanguageString)
  87 004a 90E0      		ldi r25,hi8(LanguageString)
  88               	.LVL8:
  89 004c 00C0      		rjmp .L3
  90               	.LVL9:
  91               	.L8:
 249:Descriptors.c **** 				Size    = ProductString.Header.Size;
  92               		.loc 1 249 0
  93 004e 2AE1      		ldi r18,lo8(26)
  94 0050 30E0      		ldi r19,0
 248:Descriptors.c **** 				Address = &ProductString;
  95               		.loc 1 248 0
  96 0052 80E0      		ldi r24,lo8(ProductString)
  97 0054 90E0      		ldi r25,hi8(ProductString)
  98               	.LVL10:
  99 0056 00C0      		rjmp .L3
 100               	.LVL11:
 101               	.L9:
 253:Descriptors.c **** 				Size	= ManufNameString.Header.Size;
 102               		.loc 1 253 0
 103 0058 20E1      		ldi r18,lo8(16)
 104 005a 30E0      		ldi r19,0
 252:Descriptors.c **** 				Address = &ManufNameString;
 105               		.loc 1 252 0
 106 005c 80E0      		ldi r24,lo8(ManufNameString)
 107 005e 90E0      		ldi r25,hi8(ManufNameString)
 108               	.LVL12:
 109               	.L3:
 259:Descriptors.c **** 	*DescriptorAddress = Address;
 110               		.loc 1 259 0
 111 0060 FA01      		movw r30,r20
 112 0062 9183      		std Z+1,r25
 113 0064 8083      		st Z,r24
 114               		.loc 1 261 0
 115 0066 C901      		movw r24,r18
 116               	.LVL13:
 117 0068 0895      		ret
 118               		.cfi_endproc
 119               	.LFE94:
 121               	.global	ManufNameString
 122               		.section	.rodata
 125               	ManufNameString:
 126 0000 10        		.byte	16
 127 0001 03        		.byte	3
 128 0002 4600      		.string	"F"
 129 0004 6100      		.string	"a"
 130 0006 6200      		.string	"b"
 131 0008 7500      		.string	"u"
 132 000a 6C00      		.string	"l"
 133 000c 6500      		.string	"e"
 134 000e 2000      		.string	" "
 135 0010 00        		.string	""
 136 0011 00        		.string	""
 137               	.global	ProductString
 140               	ProductString:
 141 0012 1A        		.byte	26
 142 0013 03        		.byte	3
 143 0014 4300      		.string	"C"
 144 0016 6C00      		.string	"l"
 145 0018 7900      		.string	"y"
 146 001a 6400      		.string	"d"
 147 001c 6500      		.string	"e"
 148 001e 2000      		.string	" "
 149 0020 2000      		.string	" "
 150 0022 2000      		.string	" "
 151 0024 2000      		.string	" "
 152 0026 2000      		.string	" "
 153 0028 2000      		.string	" "
 154 002a 2000      		.string	" "
 155 002c 00        		.string	""
 156 002d 00        		.string	""
 157               	.global	LanguageString
 160               	LanguageString:
 161 002e 04        		.byte	4
 162 002f 03        		.byte	3
 163 0030 0904      		.word	1033
 164               	.global	ConfigurationDescriptor
 167               	ConfigurationDescriptor:
 168 0032 09        		.byte	9
 169 0033 02        		.byte	2
 170 0034 3E00      		.word	62
 171 0036 02        		.byte	2
 172 0037 01        		.byte	1
 173 0038 00        		.byte	0
 174 0039 80        		.byte	-128
 175 003a 32        		.byte	50
 176 003b 09        		.byte	9
 177 003c 04        		.byte	4
 178 003d 00        		.byte	0
 179 003e 00        		.byte	0
 180 003f 01        		.byte	1
 181 0040 02        		.byte	2
 182 0041 02        		.byte	2
 183 0042 01        		.byte	1
 184 0043 00        		.byte	0
 185 0044 05        		.byte	5
 186 0045 24        		.byte	36
 187 0046 00        		.byte	0
 188 0047 1001      		.word	272
 189 0049 04        		.byte	4
 190 004a 24        		.byte	36
 191 004b 02        		.byte	2
 192 004c 04        		.byte	4
 193 004d 05        		.byte	5
 194 004e 24        		.byte	36
 195 004f 06        		.byte	6
 196 0050 00        		.byte	0
 197 0051 01        		.byte	1
 198 0052 07        		.byte	7
 199 0053 05        		.byte	5
 200 0054 82        		.byte	-126
 201 0055 03        		.byte	3
 202 0056 0800      		.word	8
 203 0058 FF        		.byte	-1
 204 0059 09        		.byte	9
 205 005a 04        		.byte	4
 206 005b 01        		.byte	1
 207 005c 00        		.byte	0
 208 005d 02        		.byte	2
 209 005e 0A        		.byte	10
 210 005f 00        		.byte	0
 211 0060 00        		.byte	0
 212 0061 00        		.byte	0
 213 0062 07        		.byte	7
 214 0063 05        		.byte	5
 215 0064 04        		.byte	4
 216 0065 02        		.byte	2
 217 0066 1000      		.word	16
 218 0068 01        		.byte	1
 219 0069 07        		.byte	7
 220 006a 05        		.byte	5
 221 006b 83        		.byte	-125
 222 006c 02        		.byte	2
 223 006d 1000      		.word	16
 224 006f 01        		.byte	1
 225               	.global	DeviceDescriptor
 228               	DeviceDescriptor:
 229 0070 12        		.byte	18
 230 0071 01        		.byte	1
 231 0072 1001      		.word	272
 232 0074 02        		.byte	2
 233 0075 00        		.byte	0
 234 0076 00        		.byte	0
 235 0077 08        		.byte	8
 236 0078 2832      		.word	12840
 237 007a FA00      		.word	250
 238 007c 0100      		.word	1
 239 007e 02        		.byte	2
 240 007f 01        		.byte	1
 241 0080 00        		.byte	0
 242 0081 01        		.byte	1
 243               		.text
 244               	.Letext0:
 245               		.file 2 "c:\\program files (x86)\\atmel\\avr tools\\avr toolchain\\bin\\../lib/gcc/avr/4.7.2/../..
 246               		.file 3 "c:\\program files (x86)\\atmel\\avr tools\\avr toolchain\\bin\\../lib/gcc/avr/4.7.2/inclu
 247               		.file 4 "../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../StdDescriptors.h"
 248               		.file 5 "../LUFA-111009/LUFA/Drivers/USB/Class/Device/../Common/CDC.h"
 249               		.file 6 "Descriptors.h"
DEFINED SYMBOLS
                            *ABS*:00000000 Descriptors.c
C:\Users\Bruno\AppData\Local\Temp\ccQoUB3f.s:2      *ABS*:0000003e __SP_H__
C:\Users\Bruno\AppData\Local\Temp\ccQoUB3f.s:3      *ABS*:0000003d __SP_L__
C:\Users\Bruno\AppData\Local\Temp\ccQoUB3f.s:4      *ABS*:0000003f __SREG__
C:\Users\Bruno\AppData\Local\Temp\ccQoUB3f.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Bruno\AppData\Local\Temp\ccQoUB3f.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Bruno\AppData\Local\Temp\ccQoUB3f.s:13     .text.CALLBACK_USB_GetDescriptor:00000000 CALLBACK_USB_GetDescriptor
C:\Users\Bruno\AppData\Local\Temp\ccQoUB3f.s:167    .rodata:00000032 ConfigurationDescriptor
C:\Users\Bruno\AppData\Local\Temp\ccQoUB3f.s:228    .rodata:00000070 DeviceDescriptor
C:\Users\Bruno\AppData\Local\Temp\ccQoUB3f.s:160    .rodata:0000002e LanguageString
C:\Users\Bruno\AppData\Local\Temp\ccQoUB3f.s:140    .rodata:00000012 ProductString
C:\Users\Bruno\AppData\Local\Temp\ccQoUB3f.s:125    .rodata:00000000 ManufNameString

UNDEFINED SYMBOLS
__do_copy_data
